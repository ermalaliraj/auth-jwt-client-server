package com.ea.jwt.server.service;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTCreationException;
import com.auth0.jwt.exceptions.SignatureVerificationException;
import com.auth0.jwt.interfaces.Claim;
import com.ea.jwt.server.security.AuthClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.env.Environment;
import org.springframework.security.oauth2.jwt.JwtEncoder;
import org.springframework.stereotype.Service;

import javax.annotation.PostConstruct;
import java.io.UnsupportedEncodingException;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import static org.apache.logging.log4j.util.Strings.isEmpty;

@Service
public class JwtTokenService implements TokenService {

    private static final Logger LOG = LoggerFactory.getLogger(JwtTokenService.class);

    @Value("${jwt.server.id}")
    private String serverId;
    @Value("${jwt.server.secret}")
    private String serverSecret;
    @Value("${jwt.expiration.min}")
    public static int accessTokenExpirationInMin;

    @Value("${jwt.clients}")
    private String authClients;
    private List<AuthClient> registeredClients = new ArrayList<>();

    @Autowired
    private Environment env;
    private final JwtEncoder jwtEncoder;

    @Autowired
    public JwtTokenService(JwtEncoder jwtEncoder) {
        this.jwtEncoder = jwtEncoder;
    }

    @PostConstruct
    public void init() {
        String[] clientsNames = authClients.split(",");
        String keyPrefix = "jwt.client.";
        for (String clientName : clientsNames) {
            String clientId = env.getProperty(keyPrefix + clientName + ".id");
            String clientSecret = env.getProperty(keyPrefix + clientName + ".secret");
            if (clientId == null || clientSecret == null) {
                LOG.error("the key 'jwt.clients' and its corresponding clientId/secret is not configured correctly for each single client");
            } else {
                registeredClients.add(new AuthClient(clientName, clientId, clientSecret));
            }
        }
    }

    @Override
    public AuthClient validateClientByJwtToken(String jwtToken) {
        LOG.debug("Validating JWT-Token '{}' with any of '{}' registered clients", jwtToken, registeredClients.size());
        for (AuthClient authClient : registeredClients) {
            boolean isValid = isTokenValid(authClient.getClientId(), authClient.getSecret(), jwtToken);
            if (isValid) {
                LOG.debug("JWT token correctly validated for the client '{}'", authClient.getName());
                authClient.setVerified(true);
                return authClient;
            }
        }
        return new AuthClient();//no client found
    }

    /**
     * Validate if the token has been previously generated by the server.
     * AccessTokens are generated by the server, and jwtToken(jwt-bearer) by the client.
     * @return true, if the token can be verified by the server.
     */
    public boolean validateAccessToken(String token) {
        return isTokenValid(serverId, serverSecret, token);
    }

    private boolean isTokenValid(String clientId, String secret, String token) {
        try {
            JWT.require(Algorithm.HMAC256(secret))
                    .withIssuer(clientId)
                    .acceptExpiresAt(accessTokenExpirationInMin)
                    .build()
                    .verify(token);
            return true;
        } catch (SignatureVerificationException e) {
            return false; //wrong token
        } catch (Exception e) {
            LOG.error("Error occurred while token validation. Error: {}", e.getMessage());
            return false;
        }
    }

    public String extractUserFromToken(String jwtToken) {
        Claim claim = JWT.decode(jwtToken).getClaim("user");
        if(claim.isNull()){
            return "";
        }
        return claim.asString();
    }

    @Override
    public String getAccessToken(String user) {
        LOG.debug("Generating accessToken for user '{}'", user);
        final Instant now = Instant.now();
        return generateToken(serverId, null, null, now, now, accessTokenExpirationInMin, serverSecret, user);
    }

    private String generateToken(String clientId, String subject, String audience, Instant issuedAt, Instant notBefore,
                                 int expireInMin, String secret, String user) {

        try {
            final Instant expiresAt = issuedAt.plus(expireInMin, ChronoUnit.MINUTES);
            Algorithm algorithm = Algorithm.HMAC256(secret);
            JWTCreator.Builder builder = JWT.create()
                    .withIssuer(clientId)
                    .withSubject(subject)
                    .withAudience(audience)
                    .withIssuedAt(Date.from(issuedAt))
                    .withNotBefore(Date.from(notBefore))
                    .withExpiresAt(Date.from(expiresAt));

            if(!isEmpty(user)){
                builder.withClaim("user", user);
            }
            String token = builder.sign(algorithm);
            return token;
        } catch (UnsupportedEncodingException e) {
            //UTF-8 encoding not supported
            LOG.error("Error occurred while token validation. Error: {}", e.getMessage());
            throw new IllegalStateException(e);
        } catch (JWTCreationException e) {
            //Invalid Signing configuration / Couldn't convert Claims.
            LOG.error("Error occurred while token validation. Error: {}", e.getMessage());
            throw new IllegalStateException(e);
        }
    }

//    public String generateToken(Authentication authentication) {
//        Instant now = Instant.now();
//        String scope = authentication.getAuthorities().stream()
//                .map(GrantedAuthority::getAuthority)
//                .collect(Collectors.joining(" "));
//        JwtClaimsSet claims = JwtClaimsSet.builder()
//                .issuer("self")
//                .issuedAt(now)
//                .expiresAt(now.plus(TOKEN_EXPIRE_IN_MIN, ChronoUnit.MINUTES))
//                .subject(authentication.getName())
//                .claim("scope", scope)
//                .build();
//        return jwtEncoder.encode(JwtEncoderParameters.from(claims)).getTokenValue();
//    }

}
